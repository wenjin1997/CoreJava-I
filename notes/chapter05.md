- [第5章 继承](#第5章-继承)
  - [5.1 类、超类和子类](#51-类超类和子类)
    - [5.1.1 定义子类](#511-定义子类)
    - [5.1.2 覆盖方法](#512-覆盖方法)
    - [5.1.3 子类构造器](#513-子类构造器)
    - [5.1.4 继承层次](#514-继承层次)
    - [5.1.5 多态](#515-多态)
    - [5.1.6 理解方法调用](#516-理解方法调用)
    - [5.1.7 阻止继承：final类和方法](#517-阻止继承final类和方法)
    - [5.1.8 强制类型转换](#518-强制类型转换)
    - [5.1.9 抽象类](#519-抽象类)
  - [5.3 泛型数组列表](#53-泛型数组列表)
    - [5.3.1 声明数组列表](#531-声明数组列表)

# 第5章 继承
* 继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。
* 反射是指在程序运行期间更多地了解类及其属性的能力。
## 5.1 类、超类和子类
* “is-a”关系是继承的一个明显特征。

### 5.1.1 定义子类
* 使用关键字`extends`表示继承。

```java
public class Manager extends Employee {
    added methods and fields
}
```
* 在Java中，所有的继承都是公共继承。
* 已存在的类称为超类、基类或父类；新类称为子类、派生类或孩子类。
* 子类比超类拥有的功能更多。
* 通过扩展超类定义子类的时候，只需要指出子类和超类的不同之处。因此在设计类的时候，应该将最一般的方法放在超类中，而将更特殊的方法放在子类中，这种将通用功能抽取到超类的做法在面向对象程序设计中十分普遍。

### 5.1.2 覆盖方法
* 我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此要用关键字super。`super.getSalary()`
* `super`不是一个对象的引用。它只是一个指示编译器调用超类方法的特殊关键字。

### 5.1.3 子类构造器
* **使用`super`调用构造器的语句必须是子类构造器的第一条语句。**
* **如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报告一个错误。**
* 关键字this有两个含义：一是指示隐式参数的引用，而是调用该类的其他构造器。见4.6.6节。
* super关键字也有两个含义：一是调用超类的方法，二是调用超类的构造器。
* 一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择适当的方法，称为动态绑定。

### 5.1.4 继承层次
* 继承并不仅限于一个层次。
* 由一个公共超类派生出来的所有类的集合称为**继承层次**。
* 在继承层次中，从某个特定的类到其祖先的路径称为该类的**继承链**。

### 5.1.5 多态
* “is-a”规则的另一种表述是替换原则。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。
* 在Java程序设计语言中，对象变量是多态的。
* 不能将超类的引用赋值给子类变量。

### 5.1.6 理解方法调用
假设要调用`x.f(args)`，隐式参数x声明为类C的一个对象。调用过程如下：
1. 编译器查看对象的声明类型和方法名。编译器将会一一列举C类中所有名为f的方法和其超类中所有名为f而且可访问的方法（超类的私有方法不可访问）。
2. 接下来，编译器要确定方法调用中提供的参数类型。
3. 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为**静态绑定**。如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用**动态绑定**。
4. 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。

* 动态绑定有一个非常重要的特性：无须对现有的代码进行修改就可以对程序进行扩展。
* 在覆盖一个方法的时候，子类方法**不能低于**超类方法的可见性。如果超类方法时public，子类方法必须也要声明为public。

### 5.1.7 阻止继承：final类和方法
* 不允许扩展的类被称为final类。
* 类中某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地称为final方法）。
* 如果将一个类声明为final，只有其中的方法自动地成为final，而**不包括字段**。
* 将方法或类声明为final的主要原因是：确保它们不会在子类中改变语义。

### 5.1.8 强制类型转换
```java
Manager boss = (Manager) staff[0];
```
* 进行强制类型转换的唯一原因是：要在暂时忽视对象的实际类型之后使用对象的全部功能。
* 在Java中，每个对象变量都有一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。
* 如果将一个子类的引用赋给一个超类变量，编译器是允许的。**但将一个超类的引用赋给一个子类变量时，就承诺过多了。必须进行强制类型转换**，这样才能够通过运行时的检查。
* 综上所述：
  * 只能在继承层次内进行强制类型转换。
  * 在将超类强制转换成子类之前，应该使用`instanceof`进行检查。
* 一般情况下，最好尽量少用强制类型转换和`instanceof`运算符。

### 5.1.9 抽象类
* 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。
* 除了抽象方法之外，抽象类还可以包含字段和具体方法。
* 扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记为抽象类；另一种做法是定义全部方法，这样一来，子类就不是抽象的了。
* 即使不含抽象方法，也可以将类声明为抽象类。
* 抽象类不能实例化。
* 可以定义一个抽象类的对象变量，但是这样一个变量只能引用非抽象子类的对象。


程序清单：
* [Person.java](/code/src/ch5/abstractClasses/Person.java)
* [Employee.java](/code/src/ch5/abstractClasses/Employee.java)
* [Student.java](../code/src/ch5/abstractClasses/Student.java)
* [PersonTest.java](../code/src/ch5/abstractClasses/PersonTest.java)

## 5.3 泛型数组列表
* ArrayList类类似数组，可以解决分配数组容量的问题。
* ArrayList是一个带有类型参数的泛型类。

### 5.3.1 声明数组列表
* 声明和构造一个数组列表：
```java
ArrayList<Employee> staff = new ArrayList<Employee>();
// 或者
ArrayList<Employee> staff = new ArrayList<>();
```
* add方法：添加元素到数组列表中。
* ensureCapacity方法：已经知道或估计出数组列表的大小。